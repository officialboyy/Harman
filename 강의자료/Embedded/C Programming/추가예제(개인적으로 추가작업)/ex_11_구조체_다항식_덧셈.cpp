/*	11. 구조체
	다항식을 구조체로 표현하고 두 다항식의 덧셈을 구하기
*/

#include <stdio.h>

#define MAX(a,b) ((a>b)?a:b)
#define MAX_DEGREE 50			//최대 차수

typedef struct					// 구조체 polynomial 정의
{
    int degree;                 // 다항식의 차수를 저장할 변수
	float coef[MAX_DEGREE];		// 다항식의 각 항의 계수를 저장할 1차원 배열
} polynomial;

polynomial add_poly(polynomial A, polynomial B);
void print_poly(polynomial P);

int main()
{
	polynomial A={3, {4,3,5,0}};	// 다항식 A의 초기화
	polynomial B={4, {3,1,0,2,1}};	// 다항식 B의 초기화

	polynomial C;

	C = add_poly(A,B);				// 다항식 A, B에 대한 덧셈을 수행하기 위해 add_poly 함수 호출 

	printf("\n A(x)=");  print_poly(A);     // 다항식 A 출력
	printf("\n B(x)=");  print_poly(B);     // 다항식 B 출력
	printf("\n C(x)=");  print_poly(C);     // 다항식 C 출력

	return 0;
}

 
polynomial add_poly(polynomial A, polynomial B)
{
	polynomial C;              // 다항식 덧셈의 결과 다항식을 저장할 polynomial 구조체 변수 선언
	int A_index=0, B_index=0, C_index=0;
	int A_degree=A.degree, B_degree=B.degree;
	C.degree=MAX(A.degree, B.degree);

	while (A_index<=A.degree && B_index<=B.degree)
	{
	   if(A_degree > B_degree)
	   {
 		 C.coef[C_index++] = A.coef[A_index++];
 		 A_degree--;
	   }
	   else if (A_degree == B_degree)
	   {
 		 C.coef[C_index++]=A.coef[A_index++]+B.coef[B_index++];
 		 A_degree--;
 		 B_degree--;
	   }
	   else
	   {
		 C.coef[C_index++] = B.coef[B_index++];
 		 B_degree--;
	   }
	}

	return C;			// 다항식 덧셈의 결과 다항식 C를 반환
}

void print_poly(polynomial P)
{
	int i, degree;
	degree = P.degree;

	for (i=0; i<=P.degree; i++)
 		printf("%3.0fx^%d", P.coef[i], degree--);
	printf("\n");
}



/*
 A(x)=  4x^3  3x^2  5x^1  0x^0

 B(x)=  3x^4  1x^3  0x^2  2x^1  1x^0

 C(x)=  3x^4  5x^3  3x^2  7x^1  1x^0

*/